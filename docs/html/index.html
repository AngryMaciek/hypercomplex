<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hypercomplex: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hypercomplex
   </div>
   <div id="projectbrief">Abstract &amp; fast header-only C++ template library for lattice-based cryptosystems in high-dimensional algebras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p >The following library aims to deliver a simple method to construct hypercomplex numbers from any of the Cayley-Dickson algebras. It supports calculations in an arbitrary-precise arithmetic as well as encryption/decryption procedures for public-key lattice-based cryptosystems in high-dimensional algebras of truncated polynomial rings. The library is dedicated mostly to computational mathematicians and computational scientists whose focus is (post-quantum) cryptography and precise computation. As a header-only C++ template code it's greatest advantage is the combination of speed, generic programming and convenience for the end user, making it well suited for wide range of computationally challenging projects.</p>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<p >As a prerequisite it is essential to install the <a href="https://www.mpfr.org/">MPFR library</a> first. This should be rather straightforward with the following commands: </p><div class="fragment"><div class="line"><span class="preprocessor"># Linux (apt-get package manager)</span></div>
<div class="line">sudo apt-get update -y</div>
<div class="line">sudo apt-get install -y libmpfr-dev</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># macOS (Homebrew package manager)</span></div>
<div class="line">brew update</div>
<div class="line">brew install mpfr</div>
</div><!-- fragment --><p >The following is a <em>header-only</em> library, meaning that the easiest way to use it is to copy the core <em>hpp</em> file alongside the main program and include it into the code with the directive: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_hypercomplex_8hpp.html">Hypercomplex.hpp</a>&quot;</span></div>
<div class="ttc" id="a_hypercomplex_8hpp_html"><div class="ttname"><a href="_hypercomplex_8hpp.html">Hypercomplex.hpp</a></div></div>
</div><!-- fragment --><p >Remember to specify a proper langauge standard for the compiler as well as linking with <em>GNU MP</em> and <em>GNU MPFR</em> libraries, as in the command below: </p><div class="fragment"><div class="line">g++ -02 --std=c++17 test.cpp -o test -lmpfr -lgmp</div>
</div><!-- fragment --><h1><a class="anchor" id="usecase_sec"></a>
Brief overview</h1>
<p >The following section demonstrates general functionality and behaviour of the library. For the full unit test suite please refer to <a href="https://github.com/AngryMaciek/hypercomplex/blob/master/.test/unit/test.cpp">this file</a>.</p>
<p >Please note that throughout this whole documentation many links may point to the main template <em>Hypercomplex</em> class instead of its specialisations. This is because the doxygen engine unfortunately cannot distinguish between template classes of the same name properly. Always check the description carefully while accessing links at this page.</p>
<p >Let us construct two hypercomplex numbers from an algebra obtained with the Cayley-Dickson process. For simplicity of the presentation we will focus on quaternions.</p>
<p >\( H_1=(1,0,-0.5,5)\)</p>
<p >\( H_2=(-2,-4,-6,0)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> arr1[4] = {1.0,0.0,-0.5,5.0};</div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;double, 4&gt;</a> H1(arr1);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H1 = &quot;</span> &lt;&lt; H1 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> arr2[4] = {-2.0,-4.0,-6.0,0.0};</div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;double, 4&gt;</a> H2(arr2);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H2 = &quot;</span> &lt;&lt; H2 &lt;&lt; std::endl;</div>
<div class="ttc" id="aclass_hypercomplex_html"><div class="ttname"><a href="class_hypercomplex.html">Hypercomplex</a></div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:39</div></div>
</div><!-- fragment --><p >The code above results in: </p><div class="fragment"><div class="line">H1 = 1 0 -0.5 5</div>
<div class="line">H2 = -2 -4 -6 0</div>
</div><!-- fragment --><p >For every hypercomplex number we may extract its' real as well as imaginary part:</p>
<p >\(Re(H) := (H^{(0)}, 0, 0, 0, \dotsc)\)</p>
<p >\(Im(H) := (0, H^{(1)}, H^{(2)}, H^{(3)}, \dotsc)\)</p>
<p >Therefore the commands: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Re(H1) = &quot;</span> &lt;&lt; <a class="code hl_function" href="_hypercomplex_8hpp.html#a141e88ed6b5c9bf20a877928bff456e0">Re</a>(H1) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Im(H1) = &quot;</span> &lt;&lt; <a class="code hl_function" href="_hypercomplex_8hpp.html#ab232dad8df7b0f66c9cc201bca82f9a5">Im</a>(H1) &lt;&lt; std::endl;</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a141e88ed6b5c9bf20a877928bff456e0"><div class="ttname"><a href="_hypercomplex_8hpp.html#a141e88ed6b5c9bf20a877928bff456e0">Re</a></div><div class="ttdeci">Hypercomplex&lt; T, dim &gt; Re(const Hypercomplex&lt; T, dim &gt; &amp;H)</div><div class="ttdoc">Real part of a hypercomplex number.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:627</div></div>
<div class="ttc" id="a_hypercomplex_8hpp_html_ab232dad8df7b0f66c9cc201bca82f9a5"><div class="ttname"><a href="_hypercomplex_8hpp.html#ab232dad8df7b0f66c9cc201bca82f9a5">Im</a></div><div class="ttdeci">Hypercomplex&lt; T, dim &gt; Im(const Hypercomplex&lt; T, dim &gt; &amp;H)</div><div class="ttdoc">Imaginary part of a hypercomplex number.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:635</div></div>
</div><!-- fragment --><p >yield: </p><div class="fragment"><div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a141e88ed6b5c9bf20a877928bff456e0">Re</a>(H1) = 1 0 0 0</div>
<div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#ab232dad8df7b0f66c9cc201bca82f9a5">Im</a>(H1) = 0 0 -0.5 5</div>
</div><!-- fragment --><p >In case you already forgot what the dimensionality of our objects is, don't worry - we got your back. Asking the right questions...</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;dim(H1) = &quot;</span> &lt;&lt; H1._() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >...leads to right answers:</p>
<div class="fragment"><div class="line">dim(H1) = 4</div>
</div><!-- fragment --><p >It would be very nice if we could access the components directly... But we can! </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H2(2) = &quot;</span> &lt;&lt; H2[2] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >results in:</p>
<div class="fragment"><div class="line">H2(2) = -6</div>
</div><!-- fragment --><p >Do you wish you could represent your objects in different systems? Nothing easier than that. Embedding lower-dimensional hypercomplex numbers into higher dimensional algebras is a piece of cake! </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Oct(H1) = &quot;</span> &lt;&lt; H1.expand&lt;8&gt;() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >The template method above creates a new class instance, printed below:</p>
<div class="fragment"><div class="line">Oct(H1) = 1 0 -0.5 5 0 0 0 0</div>
</div><!-- fragment --><p >For every hypercomplex number we might calculate its' Euclidean norm:</p>
<p >\(||H||_2 := \sqrt{H^{(0)}\times H^{(0)} + \dotsc + H^{(n-1)} \times H^{(n-1)} }\)</p>
<p >Luckily, there is a function dedicated to this operation: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;||H2|| = &quot;</span> &lt;&lt; H2.norm() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >It returns value of the same type as the template type for the base class:</p>
<div class="fragment"><div class="line">||H2|| = 7.48331</div>
</div><!-- fragment --><p >Having defined a norm for every non-zero hypercomplex number we may calculate its' inverse according to the following formula: \(H^{-1} = \frac{\bar{H}}{||H||_2^2}\)</p>
<p >Calling a class method... </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H2^-1 = &quot;</span> &lt;&lt; H2.inv() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >...creates a new class instance: </p><div class="fragment"><div class="line">H2^-1 = -0.0357143 0.0714286 0.107143 -0</div>
</div><!-- fragment --><p >Arithmetic operations on hypercomplex numbers are not complicated at all.</p><ul>
<li>Addition is carried out over respective elements: <br  />
 \(\forall_{H_A, H_B}: [H_A+H_B]^{(i)} := H_A^{(i)} + H_B^{(i)}\)</li>
<li>Subtraction is carried out over respective elements: <br  />
 \(\forall_{H_A, H_B}: [H_A-H_B]^{(i)} := H_A^{(i)} - H_B^{(i)}\)</li>
<li>A general formula for multiplication of hypercomplex numbers may be derived as follows: <br  />
 Let \(H_A\) and \(H_B\) be elements from a Cayley-Dickson algebra of dimension \(2^n\). <br  />
 Both numbers may be interpreted as ordered pairs of elements from a \(2^{(n-1)}\)-dimensional algebra: \(H_A = (a,b)\) and \(H_B = (c,d)\). <br  />
 Such a representation yields a recursive multiplication algorithm: <br  />
 \(H_A \times H_B = (a,b)(c,d) := (ac-\bar{d}b,da+b\bar{c})\). <br  />
 (Multiplication of hypercomplex numbers is indeed implemented as a recursive operator with the base condition of multiplying real numbers.) <br  />
 <b>Disclaimer:</b> Various distinct definitions of the multiplication formula exist: <a href="https://en.wikipedia.org/wiki/Cayley%E2%80%93Dickson_construction">here</a>, <a href="https://ncatlab.org/nlab/show/Cayley-Dickson+construction">here</a> or <a href="http://www.zipcon.net/~swhite/docs/math/quaternions/Cayley-Dickson.html">here</a>. <br  />
 They all lead to a proper norm upon multiplying a number with it's conjugate and the choice is arbitrary (feel free to modify the code, if needed). <br  />
 In addition to the overloaded operator, hypercomplex multiplication is also available as a class method. <br  />
 Depending on the dimenion of algebra and compiler's optimisation settings it could be 5-50x faster than the overloaded operator. <br  />
</li>
<li>Knowing that inverse elements of hypercomplex numbers exist a division operation is implementat as a multiplication with an inverse of the right operand: <br  />
 Let \(H_A\) and \(H_B\) be elements from a Cayley-Dickson algebra of dimension \(2^n\), \(H_B \neq 0\). <br  />
 \(\frac{H_A}{H_B} := H_A \times H_B^{-1}\) <br  />
 Notice the order of the operands, as commutativity is no longer a given.</li>
</ul>
<p >To test these operations we may execute the code below: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H1 + H2 = &quot;</span> &lt;&lt; H1 + H2 &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H1 - H2 = &quot;</span> &lt;&lt; H1 - H2 &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H1 * H2 = &quot;</span> &lt;&lt; H1 * H2 &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H1 / H2 = &quot;</span> &lt;&lt; H1 / H2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >Obtained output should match: </p><div class="fragment"><div class="line">H1 + H2 = -1 -4 -6.5 5</div>
<div class="line">H1 - H2 = 3 4 5.5 5</div>
<div class="line">H1 * H2 = -5 26 -25 -12</div>
<div class="line">H1 / H2 = 0.0178571 -0.464286 0.482143 -0.142857</div>
</div><!-- fragment --><p >Moreover, one can easily raise a hypercomplex number to a natural power: \((H^n, n\in N)\). This operation is implemented simply as an iterative multiplication:</p>
<p >\(H^n := (\dotsc((H \times H) \times H)\dotsc)\)</p>
<p >Please note that the products are evaluated from LHS to RHS. However, all Cayley-Dickson algebras are power-associative therefore it does not really matter.</p>
<p >Calling: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;H2^4 = &quot;</span> &lt;&lt; (H2^4) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >Produces: </p><div class="fragment"><div class="line">H2^4 = 1472 -1536 -2304 0</div>
</div><!-- fragment --><p >Last, but not least: our little cherry on top. A very special function linked to the magical Euler number - hypercomplex exponentiation:</p>
<p >\(e^H = e^{Re(H)+Im(H)} := e^{Re(H)} \times (cos||Im(H)||_2 + \frac{Im(H)}{||Im(H)||_2} \times sin||Im(H)||_2)\)</p>
<p >Regardless of the algebra hypercomplex numbers in the equation above are multiplied by scalars, therefore associativity and commutativity still holds for these formulas. <br  />
 For that reason the exponentiation function is highly optimized, implemented efficiently with as few operations and variables as possible.</p>
<p >Finally, we validate it with: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;e^H1 = &quot;</span> &lt;&lt; <a class="code hl_function" href="_hypercomplex_8hpp.html#acefdb8c35a0c89587789edc830ffa282">exp</a>(H1) &lt;&lt; std::endl;</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_acefdb8c35a0c89587789edc830ffa282"><div class="ttname"><a href="_hypercomplex_8hpp.html#acefdb8c35a0c89587789edc830ffa282">exp</a></div><div class="ttdeci">Hypercomplex&lt; T, dim &gt; exp(const Hypercomplex&lt; T, dim &gt; &amp;H)</div><div class="ttdoc">Exponentiation operation on a hypercomplex number.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:643</div></div>
</div><!-- fragment --><p >and get: </p><div class="fragment"><div class="line">e^H1 = 0.83583 -0 0.257375 -2.57375</div>
</div><!-- fragment --><h1><a class="anchor" id="mpfr_sec"></a>
Arbitrary-precision arithmetic</h1>
<p >Calculations on <em>MPFR</em> types are availabla via partial template specialisation (meaning that the <em>hpp</em> file already includes the necessary header and the user should not include it again). It is strongly advised to read the <a href="https://www.mpfr.org/mpfr-current/mpfr.pdf">library manual</a> beforehand (sections 1 and 4 as a must-read). Please do not mix this library with another <em>MPFR</em>-dependant code in the same translation unit.</p>
<p >We start with setting a global precision for all objects. </p><div class="fragment"><div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a0d24a46323a0a313a012f2c74cc112a8">set_mpfr_precision</a>(200);</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a0d24a46323a0a313a012f2c74cc112a8"><div class="ttname"><a href="_hypercomplex_8hpp.html#a0d24a46323a0a313a012f2c74cc112a8">set_mpfr_precision</a></div><div class="ttdeci">void set_mpfr_precision(unsigned int n)</div><div class="ttdoc">Setter for the global precision of the MPFR variables.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:679</div></div>
</div><!-- fragment --><p >What follows is an initialization of 8 <em>MPFR</em> variables in a single array: </p><div class="fragment"><div class="line">mpfr_t A[8];</div>
<div class="line">mpfr_init2(A[0], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[1], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[2], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[3], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[4], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[5], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[6], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_init2(A[7], <a class="code hl_function" href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a>());</div>
<div class="line">mpfr_set_d(A[0], 1.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[1], 2.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[2], 0.0, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[3], -1.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[4], 0.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[5], -0.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[6], -0.5, MPFR_RNDN);</div>
<div class="line">mpfr_set_d(A[7], -1.5, MPFR_RNDN);</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_aa327dde3d41d1e300e035e14b996fd82"><div class="ttname"><a href="_hypercomplex_8hpp.html#aa327dde3d41d1e300e035e14b996fd82">get_mpfr_precision</a></div><div class="ttdeci">unsigned int get_mpfr_precision()</div><div class="ttdoc">Getter for the global precision of the MPFR variables.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:672</div></div>
</div><!-- fragment --><p >Let us create an octonion composed of these numbers: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;mpfr_t, 8&gt;</a> Hx(A);</div>
</div><!-- fragment --><p >To print the first element of our number after raising it to the 30-th power we need to use library specific function: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Hx^30 = &quot;</span>;</div>
<div class="line">mpfr_out_str(stdout, 10, 0, (Hx^30)[0], MPFR_RNDN);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >In result we obtain: </p><div class="fragment"><div class="line">Hx^30 = -1.1841044160704622190868522692471742630004882812500000000000000e17</div>
</div><!-- fragment --><p >After all the calculations it is essential to clear constructed objects from the memory manually: </p><div class="fragment"><div class="line">mpfr_clear(A[0]);</div>
<div class="line">mpfr_clear(A[1]);</div>
<div class="line">mpfr_clear(A[2]);</div>
<div class="line">mpfr_clear(A[3]);</div>
<div class="line">mpfr_clear(A[4]);</div>
<div class="line">mpfr_clear(A[5]);</div>
<div class="line">mpfr_clear(A[6]);</div>
<div class="line">mpfr_clear(A[7]);</div>
</div><!-- fragment --><p >Also, following that, to call a wrapper function which cleans all internally-reserved memory: </p><div class="fragment"><div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a5214ea26b252ebf7b5e10d153df22ef4">clear_mpfr_memory</a>();</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a5214ea26b252ebf7b5e10d153df22ef4"><div class="ttname"><a href="_hypercomplex_8hpp.html#a5214ea26b252ebf7b5e10d153df22ef4">clear_mpfr_memory</a></div><div class="ttdeci">void clear_mpfr_memory()</div><div class="ttdoc">Wrapper for MPFR memory cleanup.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:685</div></div>
</div><!-- fragment --><p >All the code specified up to this point may be executed upon compilation of <a href="https://github.com/AngryMaciek/hypercomplex/blob/master/.test/docs/test.cpp">this source code</a>.</p>
<h1><a class="anchor" id="crypto_sec"></a>
Cryptographic Application</h1>
<p >The main feature of <em>Hypercomplex</em> is an implementation of cryptographic operations as in <a href="https://en.wikipedia.org/wiki/NTRUEncrypt">NTRU cryptosystem</a> but generalized on an arbitrary-high-dimensional algebras generated with the Cayley-Dickson construction. The library provides additional helper class for truncated polynomials (with necessary operators e.g. modular reduction, convolution-multiplication) and a partial template specialisation for hypercomplex numbers based on these objects.</p>
<p >Briefly, let \(N, p, q\) denote three selected primes such that \(p &lt;&lt; q\). The former will become a multiplicative order whereas the two latter will mark characteristics of the structures we will work on. Let \(R = \mathbb{Z}[x] / (x^N - 1)\) be the underlying polynomial quotient ring ( \(R_p, R_q\) are modular structures, modulo \(p,q\) respectively) and \(D\) mark the dimension of the algebra we operate in: \(A = \{x_0 + \sum^{D-1}_{i=1} x_i \cdot e_i | x_i \in R\} \), where all \(e_i\) are imaginary basis elements (similarly for modular algebras: \(A_p, A_q\)).</p>
<p >Mathematical derivations for these structures and their operations are analogous to those presented for <a href="https://eprint.iacr.org/2009/386.pdf">QTRU</a> and <a href="https://www.math.uci.edu/~brusso/cryptographyORTU.pdf">OTRU</a>.</p>
<p >Imagine that Alice wishes to send a message to Bob. Bob chooses \(F \in A\) such that \(F_p^{-1} \in A_p\) and \(F_q^{-1} \in A_q\) exist, then generates his public key for the cryptosystem:</p>
<p >\( H = F_q^{-1} \times G \mod q\)</p>
<p >Alice chooses a "blinding element" \(\Phi \in A_q\) and encrypts her top secret message \(M\) as:</p>
<p >\( E = (p \cdot H \times \Phi + M) \mod q\)</p>
<p >Which Bob then decrypts with the following operations:</p>
<p >\( C_1 = ((F \times E) \times F) \mod q\)</p>
<p >\( C_2 = C_1 \mod p\)</p>
<p >\( C_3 = (F_p^{-1} \times (C_2 \times F_p^{-1})) \mod p\)</p>
<p >If the decryption was successfull Bob receives \( C_3 = M\) (up to coefficients' centered lift)</p>
<p >Please remember that lattice-based cryptography is always burdened with a chance of decryption failure due to incorrect recovery of polynomial's coefficients at the centered lift step.</p>
<p >With a simple example of how to create a hypercomplex number based on truncated polynomials... </p><div class="fragment"><div class="line">int64_t X_array1[] = {2, 1, 1, 0, 2};</div>
<div class="line">int64_t X_array2[] = {2, 2, 2, 1, 2};</div>
<div class="line"><a class="code hl_class" href="class_polynomial.html">Polynomial&lt;5&gt;</a> X_polynomial1(X_array1);</div>
<div class="line"><a class="code hl_class" href="class_polynomial.html">Polynomial&lt;5&gt;</a> X_polynomial2(X_array2);</div>
<div class="line"><a class="code hl_class" href="class_polynomial.html">Polynomial&lt;5&gt;</a> X_coefficients[] = { X_polynomial1, X_polynomial2 };</div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;Polynomial&lt;5&gt;</a>, 2&gt; X(X_coefficients);</div>
<div class="ttc" id="aclass_polynomial_html"><div class="ttname"><a href="class_polynomial.html">Polynomial</a></div><div class="ttdef"><b>Definition:</b> Polynomial.hpp:41</div></div>
</div><!-- fragment --><p >... the scheme presented above may be implemented with the following functions of the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Having defined: p, q, MaxDeg, dim, F, G, M, PHI</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># PUBLIC KEY</span></div>
<div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a9318240e82fe8b403697464a1fffad66">CenteredLift</a>(&amp;F, p);</div>
<div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a9318240e82fe8b403697464a1fffad66">CenteredLift</a>(&amp;G, p);</div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;Polynomial&lt;MaxDeg&gt;</a>, dim&gt; H = <a class="code hl_function" href="_hypercomplex_8hpp.html#a6d878416fd316d40654940455765a6b2">PUBLICKEY</a>(F, G, q);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># ENCRYPTION</span></div>
<div class="line"><a class="code hl_function" href="_hypercomplex_8hpp.html#a9318240e82fe8b403697464a1fffad66">CenteredLift</a>(&amp;PHI, p);</div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;Polynomial&lt;MaxDeg&gt;</a>, dim&gt; E = <a class="code hl_function" href="_hypercomplex_8hpp.html#a838b097d48a6ea322263177a2abfdc3f">ENCRYPT</a>(H, M, PHI, p, q);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># DECRYPTION</span></div>
<div class="line"><a class="code hl_class" href="class_hypercomplex.html">Hypercomplex&lt;Polynomial&lt;MaxDeg&gt;</a>, dim&gt; C = <a class="code hl_function" href="_hypercomplex_8hpp.html#a2483ac8890c9f890f8be7a57e8558d12">DECRYPT</a>(F, E, p, q);</div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a2483ac8890c9f890f8be7a57e8558d12"><div class="ttname"><a href="_hypercomplex_8hpp.html#a2483ac8890c9f890f8be7a57e8558d12">DECRYPT</a></div><div class="ttdeci">Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; DECRYPT(const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;F, const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;E, const int64_t &amp;p, const int64_t &amp;q)</div><div class="ttdoc">Decrypt a message via the cryptosystem.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:1858</div></div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a6d878416fd316d40654940455765a6b2"><div class="ttname"><a href="_hypercomplex_8hpp.html#a6d878416fd316d40654940455765a6b2">PUBLICKEY</a></div><div class="ttdeci">Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; PUBLICKEY(const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;F, const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;G, const int64_t &amp;q)</div><div class="ttdoc">Generate public key of the cryptosystem.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:1818</div></div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a838b097d48a6ea322263177a2abfdc3f"><div class="ttname"><a href="_hypercomplex_8hpp.html#a838b097d48a6ea322263177a2abfdc3f">ENCRYPT</a></div><div class="ttdeci">Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; ENCRYPT(const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;H, const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;M, const Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; &amp;PHI, const int64_t &amp;p, const int64_t &amp;q)</div><div class="ttdoc">Encrypt a message via the cryptosystem.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:1838</div></div>
<div class="ttc" id="a_hypercomplex_8hpp_html_a9318240e82fe8b403697464a1fffad66"><div class="ttname"><a href="_hypercomplex_8hpp.html#a9318240e82fe8b403697464a1fffad66">CenteredLift</a></div><div class="ttdeci">void CenteredLift(Hypercomplex&lt; Polynomial&lt; MaxDeg &gt;, dim &gt; *H, const int64_t &amp;mod)</div><div class="ttdoc">Center-lift hypercomplex elements in a modular quotient ring.</div><div class="ttdef"><b>Definition:</b> Hypercomplex.hpp:1768</div></div>
</div><!-- fragment --><p >Remarkably, for a cryptosystem based on an algebra of \(D \geq 16\) dimensions \(F\) needs to contain at most one \( x_i \in R | x_i \neq 0\). This is because sedonions (and higher) are not associative, thus the decryption process will only be possible for a specific, reduced subset of private keys.</p>
<p >Cryptographic applications of <em>Hypercomplex</em> have been extensively tested in the test case: <em>Cryptosystem based on Cayley-Dickson Algebras</em> of the <a href="https://github.com/AngryMaciek/hypercomplex/blob/master/.test/unit/test.cpp">following file</a>.</p>
<p >All tests underlying Figure 1 in the publication are available <a href="https://github.com/AngryMaciek/hypercomplex/blob/master/.test/docs/test.cpp">here</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
